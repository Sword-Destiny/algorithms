//
// Created by yuanhao on 2020-1-8.
//
#include <iostream>

using namespace std;

#define max_n 301
int dp[max_n][max_n][max_n];

//给出2个整数n和k,请问如果将n分为k份，每份均不能为0，一共有多少种不同的分发。注：仅顺序不同视为同一种分发。
//
//输入描述:
//一行两个数  n，k
//
//
//输出描述:
//一行一个整数，即不同的分法数
//示例1
//输入
//7 3
//输出
//4
//说明
//1,1,5；1,2,4；1,3,3；2,2,3
//
//备注:
//1<=n<=300,1<=k<=10
int main() {
    int n = 0;
    int m = 0;
    cin >> n;
    cin >> m;
    // dp[i,j,k]代表的含义是:将数字i分为j份且每一份均大于等于k,一共有多少种分法,(k <= i/j)
    // 比如dp[10,3,1]代表将10分为3份且每一份都大于等于1,
    // dp[10,3,1] = 8,
    // 分别为(1,1,8), (1,2,7), (1,3,6), (1,4,5), (2,2,6), (2,3,5), (2,4,4), (3,3,4),
    // <因为顺序不同视为同一种分法,为了避免重复,我们约定递增表示>
    // 而dp[10,3,2] = 4,
    // 分别为(2,2,6), (2,3,5), (2,4,4), (3,3,4),
    // 特别的,dp[i,1,k] = 1, (k <= i/j)
    for (int i = 1; i <= n; ++i) {
        int j = 1;
        for (int k = 1; k <= i / j; ++k) {
            dp[i][j][k] = 1;
        }
    }
    // 下面是核心的递推关系,
    // 一般的(j > 1)情况下:
    // dp[i,j,k] = Σ dp[i-e,j-1,e], (k ≤ e ≤ i/j).
    // 举个例子, 求dp[10,3,1],
    // 要将10分成3份,可以先从10里面分出一个1,剩下9,分成2份且每一份都要大于等于1;
    // 或者先从10里面分出一个2,剩下8,分成2份且每一份都要≥2;(因为我们分的时候约定递增,避免重复)
    // 或者先从10里面分出一个3,剩下7,分成2份且每一份都要≥3;
    // 或者先从10里面分出一个4,剩下6,分成2份且每一份都要≥4;(当然这已经不可能了)
    // 因此:dp[10,3,1] = dp[9,2,1] + dp[8,2,2] + dp[7,2,3] = 4 + 3 + 1 = 8.
    // 同理:dp[10,3,2] = dp[8,2,2] + dp[7,2,3] = 3 + 1 = 4.
    // 我们所求的是dp[n,m,1].
    // 算法时间复杂度O(n^3/m),此题n很小,时间不是问题,
    // 空间需要100多MB内存.当然dp数组中有些空间是浪费的.
    for (int i = 1; i <= n; ++i) {
        for (int j = 2; j <= m; ++j) {
            for (int k = 1; k <= i / j; ++k) {
                int idj = i / j;
                dp[i][j][k] = 0;
                for (int index = k; index <= idj; ++index) {
                    dp[i][j][k] += dp[i - index][j - 1][index];
                }
            }
        }
    }

    cout << dp[n][m][1] << endl;
}